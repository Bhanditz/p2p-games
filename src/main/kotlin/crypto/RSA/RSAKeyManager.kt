package crypto.RSA

import crypto.random.secureRandom
import entity.User
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
import org.bouncycastle.crypto.AsymmetricBlockCipher
import org.bouncycastle.crypto.encodings.PKCS1Encoding
import org.bouncycastle.crypto.engines.RSAEngine
import org.bouncycastle.crypto.params.AsymmetricKeyParameter
import org.bouncycastle.crypto.util.PrivateKeyFactory
import org.bouncycastle.crypto.util.PublicKeyFactory
import org.bouncycastle.crypto.util.SubjectPublicKeyInfoFactory
import org.bouncycastle.jce.ECNamedCurveTable
import org.bouncycastle.jce.provider.BouncyCastleProvider
import sun.misc.BASE64Decoder
import sun.misc.BASE64Encoder
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.PublicKey
import java.security.Security
import java.util.*
import javax.xml.bind.DatatypeConverter

/**
 * Created by user on 7/28/16.
 */
val ECParams = ECNamedCurveTable.getParameterSpec("secp256k1")

class RSAKeyManager {
    private val userEngines = mutableMapOf<User, AsymmetricBlockCipher>()
    private val KEY_LENGTH = 1024
    val engine = PKCS1Encoding(RSAEngine())
    private val keyPair: KeyPair
    init {
        Security.addProvider(BouncyCastleProvider())
        val keyGen = KeyPairGenerator.getInstance("RSA", "BC")
        keyGen.initialize(KEY_LENGTH, secureRandom)
        keyPair = keyGen.genKeyPair()
        //TODO - there SHOULD be better convertion
        engine.init(false, PrivateKeyFactory.createKey(keyPair.private.encoded))
    }

    /**
     * Get generated public key(string representation_
     */
    fun getPublicKey(): String {
        val b64encoder = BASE64Encoder()
        return b64encoder.encode(keyPair.public.encoded)
    }

    /**
     * register public key generated by [getPublicKey]
     * for given user
     * @param user - User to be added
     * @param publicKey - public key of given user
     */
    fun registerUser(user: User, publicKey: String){
        val b64decoder = BASE64Decoder()
        val keyParam = PublicKeyFactory.createKey(b64decoder.decodeBuffer(publicKey))
        val cypher: AsymmetricBlockCipher = PKCS1Encoding(RSAEngine())
        cypher.init(true, keyParam)
        userEngines[user] = cypher
    }

    /**
     * encode message with users public key
     */
    fun encodeForUser(user: User, msg: String): String{

        val e = userEngines[user] ?: throw NoSuchUserException("No engine for user ${user.name}")
        var len = e.inputBlockSize
        val res = StringBuilder()
        val bytes = msg.toByteArray()
        for(i in 0..bytes.size-1 step len){
            len = Math.min(len, bytes.size-i)
            res.append(toHexString(e.processBlock(bytes, i, len)))
        }
        return res.toString()
    }

    /**
     * try to decode message
     * @param msg - message to decode
     * @throws InvalidCipherTextException  - if message has incorrect format
     */
    fun decodeString(msg: String): String{
        var len = engine.inputBlockSize
        val res = StringBuilder()
        val bytes = toByteArray(msg)
        for(i in 0..bytes.size-1 step len){
            len = Math.min(len, bytes.size-i)
            res.append(String(engine.processBlock(bytes, i, len)))
        }
        return res.toString()
    }


    fun toHexString(array: ByteArray): String {
        return DatatypeConverter.printHexBinary(array)
    }

    fun toByteArray(s: String): ByteArray {
        return DatatypeConverter.parseHexBinary(s)
    }

}